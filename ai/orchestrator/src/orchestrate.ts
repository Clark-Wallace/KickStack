import { Plan, Step, RenderResult, SqlFile, CodeFile, Column } from './types';
import * as fs from 'fs';
import * as path from 'path';
import * as yaml from 'js-yaml';
import chalk from 'chalk';

export class Orchestrator {
  private promptTemplate: string;

  constructor() {
    // Load prompt template
    const promptPath = path.join(__dirname, '../prompts/plan.md');
    this.promptTemplate = fs.readFileSync(promptPath, 'utf8');
  }

  async parseIntent(naturalLanguage: string): Promise<Plan> {
    console.log(chalk.yellow('ðŸ¤– Analyzing requirements...'));
    
    // Simplified for build - would integrate with AI services
    console.log(chalk.blue('Would generate plan from:', naturalLanguage));
    
    // Return a simple example plan
    return {
      version: 1,
      summary: 'Example table generated from natural language',
      steps: [
        {
          kind: 'table' as const,
          name: 'example',
          columns: [
            { name: 'id', type: 'uuid', pk: true, nullable: false, unique: false, default: 'gen_random_uuid()' },
            { name: 'name', type: 'text', nullable: false, unique: false },
            { name: 'created_at', type: 'timestamptz', nullable: false, unique: false, default: 'now()' }
          ]
        }
      ]
    };
  }

  async generatePlan(naturalLanguage: string): Promise<Plan> {
    return this.parseIntent(naturalLanguage);
  }

  renderPlan(plan: Plan): RenderResult {
    const migrations: SqlFile[] = [];
    const functions: CodeFile[] = [];
    const timestamp = new Date().toISOString().replace(/[-:T]/g, '').slice(0, 13);
    
    for (const step of plan.steps) {
      if (step.kind === 'table') {
        // Generate CREATE TABLE migration
        const createTableSql = this.generateCreateTableSQL(step);
        migrations.push({
          name: `${timestamp}_create_${step.name}.sql`,
          content: createTableSql
        });
        
        // Generate RLS policy migration if specified
        if (step.policy) {
          const policySql = this.generatePolicySQL(step);
          migrations.push({
            name: `${timestamp}_add_policy_${step.name}.sql`,
            content: policySql
          });
        }
      } else if (step.kind === 'function') {
        // Generate edge function
        const functionCode = this.generateFunctionCode(step);
        functions.push({
          path: `/functions/${step.name}.ts`,
          content: functionCode
        });
      }
    }
    
    return { migrations, functions };
  }

  private generateCreateTableSQL(step: Step): string {
    if (step.kind !== 'table') {
      throw new Error('Step is not a table');
    }
    
    let sql = `-- Generated by KickStack AI\n`;
    sql += `CREATE TABLE IF NOT EXISTS ${step.name} (\n`;
    
    const columnDefs = step.columns?.map((col: Column) => {
      let def = `  ${col.name} ${col.type.toUpperCase()}`;
      if (col.pk) def += ' PRIMARY KEY';
      if (col.default) def += ` DEFAULT ${col.default}`;
      if (!col.nullable && !col.pk) def += ' NOT NULL';
      if (col.unique && !col.pk) def += ' UNIQUE';
      return def;
    }) || [];
    
    sql += columnDefs.join(',\n');
    sql += '\n);\n';
    
    return sql;
  }

  private generatePolicySQL(step: Step): string {
    if (step.kind !== 'table') {
      throw new Error('Step is not a table');
    }
    
    let sql = `-- RLS Policy for ${step.name}\n`;
    sql += `ALTER TABLE ${step.name} ENABLE ROW LEVEL SECURITY;\n\n`;
    
    // Generate policy based on preset
    const policy = step.policy;
    if (policy?.preset === 'owner') {
      sql += `CREATE POLICY ${step.name}_owner_select ON ${step.name}\n`;
      sql += `  FOR SELECT USING (user_id = auth.uid());\n`;
      // Add other CRUD policies...
    }
    
    return sql;
  }

  private generateFunctionCode(step: Step): string {
    return `// Generated edge function: ${step.name}
export default async function handler(req: Request): Promise<Response> {
  return new Response(JSON.stringify({ message: 'Hello from ${step.name}' }), {
    headers: { 'Content-Type': 'application/json' }
  });
}`;
  }

  savePlan(plan: Plan, filename: string): void {
    const yamlContent = yaml.dump(plan);
    fs.writeFileSync(filename, yamlContent, 'utf8');
    console.log(chalk.green(`âœ“ Plan saved to ${filename}`));
  }

  loadPlan(filename: string): Plan {
    const yamlContent = fs.readFileSync(filename, 'utf8');
    return yaml.load(yamlContent) as Plan;
  }

  private async findMatchingTemplates(naturalLanguage: string): Promise<any[]> {
    // Simplified - would search template marketplace
    return [];
  }
}